#+Title: The Advent of Code 2020
#+Author: Mark Armstrong
#+Description: A daily coding puzzle challenge from December 2020.
#+Description: My solutions implemented in Scala.

* Day  1 – Report Repair                        :scala:complete:

** Part 1

*** The narrative

After saving Christmas five years in a row, you've decided
to take a vacation at a nice resort on a tropical island.
Surely, Christmas will go on without you.

The tropical island has its own currency and is entirely cash-only.
The gold coins used there have a little picture of a starfish;
the locals just call them stars. None of the currency exchanges
seem to have heard of them, but somehow, you'll need to find
fifty of these coins by the time you arrive so you can pay
the deposit on your room.

To save your vacation, you need to get all fifty stars
by December 25th.

Collect stars by solving puzzles. Two puzzles will be made available
on each day in the Advent calendar; the second puzzle is unlocked
when you complete the first. Each puzzle grants one star. Good luck!

Before you leave, the Elves in accounting just need you
to fix your expense report (your puzzle input); apparently,
something isn't quite adding up.

Specifically, they need you to find the two entries that sum
to 2020 and then multiply those two numbers together.

For example, suppose your expense report contained the following:
#+begin_src text
1721
979
366
299
675
1456
#+end_src
In this list, the two entries that sum to 2020 are 1721 and 299.
Multiplying them together produces 1721 * 299 = 514579, so
the correct answer is 514579.

Of course, your expense report is much larger. Find the two entries
that sum to 2020; what do you get if you multiply them together?

*** The input

**** Raw

#+name: day1-input-raw
#+begin_src text
1567
1223
1758
1842
1933
1898
1409
1058
1533
1417
1032
1634
1477
1394
1888
1972
1237
1390
1677
1546
1302
1070
1369
1455
1065
1924
1593
1131
1064
1346
1914
1129
1830
1450
1278
1740
1809
1176
1734
1102
1807
1982
1603
1736
2008
1980
1905
1633
1732
1350
1865
1988
1805
1998
1152
1046
1870
1557
1789
1766
1945
1359
1002
1126
1719
1497
1296
1560
1936
1929
1464
2005
1281
618
1257
1107
1632
1688
1964
1803
1360
1384
1889
1411
1328
1452
1868
1515
1586
1631
1618
1087
1710
1094
1774
1295
1700
1636
1230
1421
1910
1522
1366
1144
1757
1493
1316
1103
687
1371
1720
1155
1559
1900
989
1367
1999
1066
1773
1787
1402
1047
1806
1956
1219
1555
1307
1419
1706
1884
1109
1181
2010
1298
1730
1078
1848
1398
1687
2007
1550
1664
1225
1079
1698
350
1222
1377
1977
1510
1571
1630
1029
1379
1942
1949
1249
1829
1297
1530
1607
1324
1069
1476
928
1039
1855
1644
1454
1310
1172
547
1034
1878
1479
1457
1319
1810
1759
1439
1851
545
1470
2003
1908
1564
1491
1174
1301
1689
1276
1781
1392
1499
1962
1653
1823
1381
1827
1974
#+end_src

**** As a Scala list

#+name: day1-input-scala
#+begin_src amm
val input = List(
  1567,
  1223,
  1758,
  1842,
  1933,
  1898,
  1409,
  1058,
  1533,
  1417,
  1032,
  1634,
  1477,
  1394,
  1888,
  1972,
  1237,
  1390,
  1677,
  1546,
  1302,
  1070,
  1369,
  1455,
  1065,
  1924,
  1593,
  1131,
  1064,
  1346,
  1914,
  1129,
  1830,
  1450,
  1278,
  1740,
  1809,
  1176,
  1734,
  1102,
  1807,
  1982,
  1603,
  1736,
  2008,
  1980,
  1905,
  1633,
  1732,
  1350,
  1865,
  1988,
  1805,
  1998,
  1152,
  1046,
  1870,
  1557,
  1789,
  1766,
  1945,
  1359,
  1002,
  1126,
  1719,
  1497,
  1296,
  1560,
  1936,
  1929,
  1464,
  2005,
  1281,
  618 ,
  1257,
  1107,
  1632,
  1688,
  1964,
  1803,
  1360,
  1384,
  1889,
  1411,
  1328,
  1452,
  1868,
  1515,
  1586,
  1631,
  1618,
  1087,
  1710,
  1094,
  1774,
  1295,
  1700,
  1636,
  1230,
  1421,
  1910,
  1522,
  1366,
  1144,
  1757,
  1493,
  1316,
  1103,
  687 ,
  1371,
  1720,
  1155,
  1559,
  1900,
  989 ,
  1367,
  1999,
  1066,
  1773,
  1787,
  1402,
  1047,
  1806,
  1956,
  1219,
  1555,
  1307,
  1419,
  1706,
  1884,
  1109,
  1181,
  2010,
  1298,
  1730,
  1078,
  1848,
  1398,
  1687,
  2007,
  1550,
  1664,
  1225,
  1079,
  1698,
  350 ,
  1222,
  1377,
  1977,
  1510,
  1571,
  1630,
  1029,
  1379,
  1942,
  1949,
  1249,
  1829,
  1297,
  1530,
  1607,
  1324,
  1069,
  1476,
  928 ,
  1039,
  1855,
  1644,
  1454,
  1310,
  1172,
  547 ,
  1034,
  1878,
  1479,
  1457,
  1319,
  1810,
  1759,
  1439,
  1851,
  545 ,
  1470,
  2003,
  1908,
  1564,
  1491,
  1174,
  1301,
  1689,
  1276,
  1781,
  1392,
  1499,
  1962,
  1653,
  1823,
  1381,
  1827,
  1974)
#+end_src

*** The code

**** The workhorses

The intuitive solution is to perform a a double walkthrough
of the list; walk through and, at each element ~e~,
perform another walkthrough and at each element ~e'~,
check if the sum of ~e~ and ~e'~ is the specified constant ~2020~.

Rather than perform the second walkthrough manually, we make use of
the ~collectFirst~ method for sequences;
see the sequence [[https://www.scala-lang.org/api/2.12.0/scala/collection/Seq.html][documentation]].
#+name: summing_pair
#+begin_src amm
/**
  * Find a pair of elements in `xs` which sum to `sum`,
  * if such elements exist.
  * If multiple such pairs exist, returns the pair
  * whose first element has the lowest index and
  * whose second element has the lowest index amongst
  * candidates to pair with that first element.
  */
def summing_pair(xs : Seq[Int], sum: Int): Option[Tuple2[Int,Int]] = xs match {
  case Nil => None
  case fst :: rest =>
    rest.collectFirst({case snd if fst + snd == sum => (fst,snd)}) match {
      case Some(pair) => Some(pair)
      case None => summing_pair(rest, sum)
    }
}
#+end_src

#+RESULTS: summing_pair
: defined function summing_pair

**** The answer

Now we apply that method to the provided input,
then match on it to produce the product of the pair.
#+begin_src amm :noweb yes
<<day1-input-scala>>
<<summing_pair>>

summing_pair(input,2020) match {
  case Some((fst,snd)) => println(s"The product of the summing pair is ${fst * snd}.")
  case None => println("Summing pair not found.")
}
#+end_src

#+RESULTS:
#+begin_example
The product of the summing pair is 866436.
input: List[Int] = List(
  1567,
  1223,
  1758,
  1842,
  1933,
  1898,
  1409,
  1058,
  1533,
  1417,
  1032,
  1634,
  1477,
  1394,
  1888,
  1972,
  1237,
  1390,
  1677,
  1546,
  1302,
  1070,
  1369,
...
defined function summing_pair
#+end_example

** Part 2

*** The narrative

The Elves in accounting are thankful for your help; one of them
even offers you a starfish coin they had left over from a past vacation.
They offer you a second one if you can find three numbers
in your expense report that meet the same criteria.

Using the above example again, the three entries that
sum to 2020 are 979, 366, and 675. Multiplying them together
produces the answer, 241861950.

In your expense report, what is the product of the three
entries that sum to 2020?

*** The input

…is the same as above.

*** The code

**** The workhorse

This generalisation of the problem requires that we move away
from the use of a tuple; of course we could move to a triple instead,
but we may as well generalise to returning a sequence of a given length.

This time we will need to recurse on the new argument ~n~ when
in the inner “loop”.
#+name: summing_seq
#+begin_src amm
/**
 ,* Find a sequence of elements of length `n`
 ,* in `xs` which sum to `sum`,
 ,* if such elements exist.
 ,* If multiple such sequences exist, returns the sequence
 ,* whose first element has the lowest index and
 ,* whose second element has the lowest index amongst
 ,* candidates to pair with that first element, etc.
 ,*/
def summing_seq(xs : Seq[Int], sum: Int, n:Int): Either[String,List[Int]] = n match {
  case 0 if sum == 0 => Right(Nil)
  case 0             => Left("Ran out of return space with some leftover amount.")
  case n if n > 0 => xs match {
    case Nil => Left("Ran out of elements with some leftover amount.")
    case fst :: rest if sum >= fst =>
      summing_seq(rest, sum-fst, n-1) match {
        case Right(ys) => Right(fst :: ys)
        case Left(_) => summing_seq(rest,sum,n)
      }
    case _ :: rest => summing_seq(rest,sum,n)
  }
  case n if n < 0 => Left("Cannot sum many negative elements")
}
#+end_src

#+RESULTS: summing_seq
: defined function summing_seq

**** The answer

Now we apply that method to the provided input,
then match on it to extract the list and take its product.
#+begin_src amm :noweb yes :results output
<<day1-input-scala>>
<<summing_seq>>

summing_seq(input,2020,3) match {
  case Right(l) => println(s"The product of the summing triple is ${l.product}.")
  case Left(s) => println(s"Summing triple not found; error ${s}.")
}
#+end_src

#+RESULTS:
#+begin_example
The product of the summing triple is 276650720.
input: List[Int] = List(
  1567,
  1223,
  1758,
  1842,
  1933,
  1898,
  1409,
  1058,
  1533,
  1417,
  1032,
  1634,
  1477,
  1394,
  1888,
  1972,
  1237,
  1390,
  1677,
  1546,
  1302,
  1070,
  1369,
  1455,
  1065,
  1924,
  1593,
  1131,
  1064,
  1346,
  1914,
  1129,
  1830,
  1450,
...
defined function summing_seq
#+end_example

* Day  2 – ???
* Day  3 – ???
* Day  4 – ???
* Day  5 – ???
* Day  6 – ???
* Day  7 – ???
* Day  8 – ???
* Day  9 – ???
* Day 10 – ???
* Day 11 – ???
* Day 12 – ???
* Day 13 – ???
* Day 14 – ???
* Day 15 – ???
* Day 16 – ???
* Day 17 – ???
* Day 18 – ???
* Day 19 – ???
* Day 20 – ???
* Day 21 – ???
* Day 22 – ???
* Day 23 – ???
* Day 24 – ???
* Day 25 – ???
